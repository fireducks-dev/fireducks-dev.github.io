<!doctype html><html itemscope itemtype=http://schema.org/WebPage lang=ja class=no-js><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><link rel="shortcut icon" href=/favicons/favicon.ico><link rel=apple-touch-icon href=/favicons/apple-touch-icon-180x180.png sizes=180x180><link rel=icon type=image/png href=/favicons/favicon-16x16.png sizes=16x16><link rel=icon type=image/png href=/favicons/favicon-32x32.png sizes=32x32><link rel=icon type=image/png href=/favicons/android-36x36.png sizes=36x36><link rel=icon type=image/png href=/favicons/android-48x48.png sizes=48x48><link rel=icon type=image/png href=/favicons/android-72x72.png sizes=72x72><link rel=icon type=image/png href=/favicons/android-96x96.png sizes=96x96><link rel=icon type=image/png href=/favicons/android-144x144.png sizes=144x144><link rel=icon type=image/png href=/favicons/android-192x192.png sizes=192x192><title>GPU版開発におけるpandasとの互換性確保 | FireDucks</title>
<meta name=description content="現在，FireDucksのGPU版の開発を進めています．
FireDucksは，プログラムを実行時に中間言語に変換し，この中間言語上で最適化を行った後，中間言語をバックエンド向けにコンパイルし，実行するアーキテクチャになっています．現在公開されているCPU版FireDucksでは，このバックエンドがCPU向けになっています．GPU版の開発においては，バックエンドをGPUに変更します．これにより，CPU版向けに開発してきた中間言語への変換や最適化をそのまま利用することができます．
GPU版バックエンドの開発には，NVIDIAのcuDFというライブラリを活用しています．我々の中間言語はpandasのAPIにおおむね対応しており，cuDFはpandasと類似したAPIを提供しているため，バックエンドの開発は一見容易に見えます．しかし，cuDFが提供する機能はpandasとは微妙に異なるため，pandasとの互換性を保つためには工夫が必要です．
今回のブログ記事では，pandasとの互換性を保つためにどのような点に課題があるか，一部ですが簡単に紹介したいと思います．
結果の型が異なる pandasで日付を扱う場合，datetime64型に変換しておくと，dtというアクセサを使って年や月，日を取り出すことができます．
df = pd.DataFrame({&amp;#34;a&amp;#34;: [&amp;#34;2017-11-01 12:24:00&amp;#34;]}) dfa = pd.to_datetime(df[&amp;#34;a&amp;#34;]) print(dfa.dt.year) とすると2017が返ってきます．ところでこの値の型は何でしょうか？ print(dfa.dt.year.dtype) とすると，pandasではint32，cuDfではint16が返ってきます．この違いはGPUのメモリ利用量を減らすための，意図的なものであるようです．
年が16bitの値を越えることはないでしょうし，大きな問題は無いように見えますが，演算に使うとオーバーフローして結果が変わる可能性があります．例えば，0年からの時間数を求めようとして， dfa.dt.year * 365 * 24 などとしてしまうと，int16ではオーバーフローするため異なる結果が出てしまいます．
この例に限らず，cuDFでは結果の型が微妙に異なることがよくあります．FireDucksではpandasとの互換性を保つため，同じ型になるように変換しています．
欠損値の演算における扱いが異なる pandasでは欠損値(RDBで言うところのNULL)は基本的にNaNで表現されています．一方，cuDFでは欠損値は特別な値(NA)として扱われています．そのため，演算結果が異なることがあります．
例えば，
df = pd.Series([1.0, 3.0, np.nan]) mask = df &amp;lt; 2.0 print (mask) などとすると，pandasでは
0 True 1 False 2 False と欠損値の所にFalseが入ります．これはnp.nanとの比較になるためです．一方，cuDFでは
0 True 1 False 2 &amp;lt;NA&amp;gt; と演算結果も欠損値(NA)になります．RDBではNULLとの演算は常にNULLになるため，RDBの演算結果とは一致しているのですが，pandasとは一致していません．これもcuDFの仕様として意図的なものではないかと思います．
pandasも欠損値として特別な値(pd.NA)が実験的に取り入れられており，これを用いる場合はcuDFやRDBと同じ結果になるのですが，そうでない場合は結果が異なることになります．FireDucksでは欠損値の処理結果の扱いをpandasと同じになるよう，結果を調整しています．
mergeの結果が異なる pandasのmergeには複雑な仕様があり，cuDFは必ずしもその仕様に準拠していないようです．将来的には変更されるかも知れませんが，現在は例えば下記のような違いがあります．
pandasのmergeでは，mergeに用いる列の指定にleft_onやright_onを使います．通常ここには列名を指定しますが，indexに名前がついている場合，index名を指定することもできます．また，left_index=Trueやright_index=Trueを指定することでもindexを指定することができます．では，これらの機能を使ってmergeを行ってみましょう．
まず，mergeするためのDataFrameを作成します．左側は
idx1 = pd.Index([1,2,3,4],name=&amp;#34;p&amp;#34;) df1 = pd.DataFrame([[1,2],[3,4],[5,6],[7,8]], columns=[&amp;#34;a&amp;#34;,&amp;#34;b&amp;#34;], index=idx1) で作成します．結果は"><meta property="og:title" content="GPU版開発におけるpandasとの互換性確保"><meta property="og:description" content="現在，FireDucksのGPU版の開発を進めています．
FireDucksは，プログラムを実行時に中間言語に変換し，この中間言語上で最適化を行った後，中間言語をバックエンド向けにコンパイルし，実行するアーキテクチャになっています．現在公開されているCPU版FireDucksでは，このバックエンドがCPU向けになっています．GPU版の開発においては，バックエンドをGPUに変更します．これにより，CPU版向けに開発してきた中間言語への変換や最適化をそのまま利用することができます．
GPU版バックエンドの開発には，NVIDIAのcuDFというライブラリを活用しています．我々の中間言語はpandasのAPIにおおむね対応しており，cuDFはpandasと類似したAPIを提供しているため，バックエンドの開発は一見容易に見えます．しかし，cuDFが提供する機能はpandasとは微妙に異なるため，pandasとの互換性を保つためには工夫が必要です．
今回のブログ記事では，pandasとの互換性を保つためにどのような点に課題があるか，一部ですが簡単に紹介したいと思います．
結果の型が異なる pandasで日付を扱う場合，datetime64型に変換しておくと，dtというアクセサを使って年や月，日を取り出すことができます．
df = pd.DataFrame({&#34;a&#34;: [&#34;2017-11-01 12:24:00&#34;]}) dfa = pd.to_datetime(df[&#34;a&#34;]) print(dfa.dt.year) とすると2017が返ってきます．ところでこの値の型は何でしょうか？ print(dfa.dt.year.dtype) とすると，pandasではint32，cuDfではint16が返ってきます．この違いはGPUのメモリ利用量を減らすための，意図的なものであるようです．
年が16bitの値を越えることはないでしょうし，大きな問題は無いように見えますが，演算に使うとオーバーフローして結果が変わる可能性があります．例えば，0年からの時間数を求めようとして， dfa.dt.year * 365 * 24 などとしてしまうと，int16ではオーバーフローするため異なる結果が出てしまいます．
この例に限らず，cuDFでは結果の型が微妙に異なることがよくあります．FireDucksではpandasとの互換性を保つため，同じ型になるように変換しています．
欠損値の演算における扱いが異なる pandasでは欠損値(RDBで言うところのNULL)は基本的にNaNで表現されています．一方，cuDFでは欠損値は特別な値(NA)として扱われています．そのため，演算結果が異なることがあります．
例えば，
df = pd.Series([1.0, 3.0, np.nan]) mask = df < 2.0 print (mask) などとすると，pandasでは
0 True 1 False 2 False と欠損値の所にFalseが入ります．これはnp.nanとの比較になるためです．一方，cuDFでは
0 True 1 False 2 <NA> と演算結果も欠損値(NA)になります．RDBではNULLとの演算は常にNULLになるため，RDBの演算結果とは一致しているのですが，pandasとは一致していません．これもcuDFの仕様として意図的なものではないかと思います．
pandasも欠損値として特別な値(pd.NA)が実験的に取り入れられており，これを用いる場合はcuDFやRDBと同じ結果になるのですが，そうでない場合は結果が異なることになります．FireDucksでは欠損値の処理結果の扱いをpandasと同じになるよう，結果を調整しています．
mergeの結果が異なる pandasのmergeには複雑な仕様があり，cuDFは必ずしもその仕様に準拠していないようです．将来的には変更されるかも知れませんが，現在は例えば下記のような違いがあります．
pandasのmergeでは，mergeに用いる列の指定にleft_onやright_onを使います．通常ここには列名を指定しますが，indexに名前がついている場合，index名を指定することもできます．また，left_index=Trueやright_index=Trueを指定することでもindexを指定することができます．では，これらの機能を使ってmergeを行ってみましょう．
まず，mergeするためのDataFrameを作成します．左側は
idx1 = pd.Index([1,2,3,4],name=&#34;p&#34;) df1 = pd.DataFrame([[1,2],[3,4],[5,6],[7,8]], columns=[&#34;a&#34;,&#34;b&#34;], index=idx1) で作成します．結果は"><meta property="og:type" content="article"><meta property="og:url" content="https://fireducks-dev.github.io/ja/posts/2024-12-19-araki/"><meta property="og:image" content="https://fireducks-dev.github.io/images/fireducks_1200x630.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-12-19T00:00:00+00:00"><meta property="article:modified_time" content="2024-12-19T00:00:00+00:00"><meta itemprop=name content="GPU版開発におけるpandasとの互換性確保"><meta itemprop=description content="現在，FireDucksのGPU版の開発を進めています．
FireDucksは，プログラムを実行時に中間言語に変換し，この中間言語上で最適化を行った後，中間言語をバックエンド向けにコンパイルし，実行するアーキテクチャになっています．現在公開されているCPU版FireDucksでは，このバックエンドがCPU向けになっています．GPU版の開発においては，バックエンドをGPUに変更します．これにより，CPU版向けに開発してきた中間言語への変換や最適化をそのまま利用することができます．
GPU版バックエンドの開発には，NVIDIAのcuDFというライブラリを活用しています．我々の中間言語はpandasのAPIにおおむね対応しており，cuDFはpandasと類似したAPIを提供しているため，バックエンドの開発は一見容易に見えます．しかし，cuDFが提供する機能はpandasとは微妙に異なるため，pandasとの互換性を保つためには工夫が必要です．
今回のブログ記事では，pandasとの互換性を保つためにどのような点に課題があるか，一部ですが簡単に紹介したいと思います．
結果の型が異なる pandasで日付を扱う場合，datetime64型に変換しておくと，dtというアクセサを使って年や月，日を取り出すことができます．
df = pd.DataFrame({&#34;a&#34;: [&#34;2017-11-01 12:24:00&#34;]}) dfa = pd.to_datetime(df[&#34;a&#34;]) print(dfa.dt.year) とすると2017が返ってきます．ところでこの値の型は何でしょうか？ print(dfa.dt.year.dtype) とすると，pandasではint32，cuDfではint16が返ってきます．この違いはGPUのメモリ利用量を減らすための，意図的なものであるようです．
年が16bitの値を越えることはないでしょうし，大きな問題は無いように見えますが，演算に使うとオーバーフローして結果が変わる可能性があります．例えば，0年からの時間数を求めようとして， dfa.dt.year * 365 * 24 などとしてしまうと，int16ではオーバーフローするため異なる結果が出てしまいます．
この例に限らず，cuDFでは結果の型が微妙に異なることがよくあります．FireDucksではpandasとの互換性を保つため，同じ型になるように変換しています．
欠損値の演算における扱いが異なる pandasでは欠損値(RDBで言うところのNULL)は基本的にNaNで表現されています．一方，cuDFでは欠損値は特別な値(NA)として扱われています．そのため，演算結果が異なることがあります．
例えば，
df = pd.Series([1.0, 3.0, np.nan]) mask = df < 2.0 print (mask) などとすると，pandasでは
0 True 1 False 2 False と欠損値の所にFalseが入ります．これはnp.nanとの比較になるためです．一方，cuDFでは
0 True 1 False 2 <NA> と演算結果も欠損値(NA)になります．RDBではNULLとの演算は常にNULLになるため，RDBの演算結果とは一致しているのですが，pandasとは一致していません．これもcuDFの仕様として意図的なものではないかと思います．
pandasも欠損値として特別な値(pd.NA)が実験的に取り入れられており，これを用いる場合はcuDFやRDBと同じ結果になるのですが，そうでない場合は結果が異なることになります．FireDucksでは欠損値の処理結果の扱いをpandasと同じになるよう，結果を調整しています．
mergeの結果が異なる pandasのmergeには複雑な仕様があり，cuDFは必ずしもその仕様に準拠していないようです．将来的には変更されるかも知れませんが，現在は例えば下記のような違いがあります．
pandasのmergeでは，mergeに用いる列の指定にleft_onやright_onを使います．通常ここには列名を指定しますが，indexに名前がついている場合，index名を指定することもできます．また，left_index=Trueやright_index=Trueを指定することでもindexを指定することができます．では，これらの機能を使ってmergeを行ってみましょう．
まず，mergeするためのDataFrameを作成します．左側は
idx1 = pd.Index([1,2,3,4],name=&#34;p&#34;) df1 = pd.DataFrame([[1,2],[3,4],[5,6],[7,8]], columns=[&#34;a&#34;,&#34;b&#34;], index=idx1) で作成します．結果は"><meta itemprop=datePublished content="2024-12-19T00:00:00+00:00"><meta itemprop=dateModified content="2024-12-19T00:00:00+00:00"><meta itemprop=wordCount content="200"><meta itemprop=image content="https://fireducks-dev.github.io/images/fireducks_1200x630.png"><meta itemprop=keywords content><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://fireducks-dev.github.io/images/fireducks_1200x630.png"><meta name=twitter:title content="GPU版開発におけるpandasとの互換性確保"><meta name=twitter:description content="現在，FireDucksのGPU版の開発を進めています．
FireDucksは，プログラムを実行時に中間言語に変換し，この中間言語上で最適化を行った後，中間言語をバックエンド向けにコンパイルし，実行するアーキテクチャになっています．現在公開されているCPU版FireDucksでは，このバックエンドがCPU向けになっています．GPU版の開発においては，バックエンドをGPUに変更します．これにより，CPU版向けに開発してきた中間言語への変換や最適化をそのまま利用することができます．
GPU版バックエンドの開発には，NVIDIAのcuDFというライブラリを活用しています．我々の中間言語はpandasのAPIにおおむね対応しており，cuDFはpandasと類似したAPIを提供しているため，バックエンドの開発は一見容易に見えます．しかし，cuDFが提供する機能はpandasとは微妙に異なるため，pandasとの互換性を保つためには工夫が必要です．
今回のブログ記事では，pandasとの互換性を保つためにどのような点に課題があるか，一部ですが簡単に紹介したいと思います．
結果の型が異なる pandasで日付を扱う場合，datetime64型に変換しておくと，dtというアクセサを使って年や月，日を取り出すことができます．
df = pd.DataFrame({&#34;a&#34;: [&#34;2017-11-01 12:24:00&#34;]}) dfa = pd.to_datetime(df[&#34;a&#34;]) print(dfa.dt.year) とすると2017が返ってきます．ところでこの値の型は何でしょうか？ print(dfa.dt.year.dtype) とすると，pandasではint32，cuDfではint16が返ってきます．この違いはGPUのメモリ利用量を減らすための，意図的なものであるようです．
年が16bitの値を越えることはないでしょうし，大きな問題は無いように見えますが，演算に使うとオーバーフローして結果が変わる可能性があります．例えば，0年からの時間数を求めようとして， dfa.dt.year * 365 * 24 などとしてしまうと，int16ではオーバーフローするため異なる結果が出てしまいます．
この例に限らず，cuDFでは結果の型が微妙に異なることがよくあります．FireDucksではpandasとの互換性を保つため，同じ型になるように変換しています．
欠損値の演算における扱いが異なる pandasでは欠損値(RDBで言うところのNULL)は基本的にNaNで表現されています．一方，cuDFでは欠損値は特別な値(NA)として扱われています．そのため，演算結果が異なることがあります．
例えば，
df = pd.Series([1.0, 3.0, np.nan]) mask = df < 2.0 print (mask) などとすると，pandasでは
0 True 1 False 2 False と欠損値の所にFalseが入ります．これはnp.nanとの比較になるためです．一方，cuDFでは
0 True 1 False 2 <NA> と演算結果も欠損値(NA)になります．RDBではNULLとの演算は常にNULLになるため，RDBの演算結果とは一致しているのですが，pandasとは一致していません．これもcuDFの仕様として意図的なものではないかと思います．
pandasも欠損値として特別な値(pd.NA)が実験的に取り入れられており，これを用いる場合はcuDFやRDBと同じ結果になるのですが，そうでない場合は結果が異なることになります．FireDucksでは欠損値の処理結果の扱いをpandasと同じになるよう，結果を調整しています．
mergeの結果が異なる pandasのmergeには複雑な仕様があり，cuDFは必ずしもその仕様に準拠していないようです．将来的には変更されるかも知れませんが，現在は例えば下記のような違いがあります．
pandasのmergeでは，mergeに用いる列の指定にleft_onやright_onを使います．通常ここには列名を指定しますが，indexに名前がついている場合，index名を指定することもできます．また，left_index=Trueやright_index=Trueを指定することでもindexを指定することができます．では，これらの機能を使ってmergeを行ってみましょう．
まず，mergeするためのDataFrameを作成します．左側は
idx1 = pd.Index([1,2,3,4],name=&#34;p&#34;) df1 = pd.DataFrame([[1,2],[3,4],[5,6],[7,8]], columns=[&#34;a&#34;,&#34;b&#34;], index=idx1) で作成します．結果は"><link rel=preload href=/scss/main.min.2404b01c5fb65f0b4d76f0c632723d405f2faf20557f5aeff94d8efb2e91ec8b.css as=style><link href=/scss/main.min.2404b01c5fb65f0b4d76f0c632723d405f2faf20557f5aeff94d8efb2e91ec8b.css rel=stylesheet integrity><script src=https://code.jquery.com/jquery-3.6.3.min.js integrity="sha512-STof4xm1wgkfm7heWqFJVn58Hm3EtS31XFaagaa8VMReCXAkQnJZ+jEy8PCC/iT18dFy95WcExNHFTqLyp72eQ==" crossorigin=anonymous></script></head><body class="td-page td-blog"><header><nav class="td-navbar navbar-dark js-navbar-scroll"><div class="container-fluid flex-column flex-md-row"><a class=navbar-brand href=/ja/><span class="navbar-brand__logo navbar-logo"></span><span class=navbar-brand__name>FireDucks</span></a><div class="td-navbar-nav-scroll ms-md-auto" id=main_navbar><ul class=navbar-nav><li class=nav-item><a class=nav-link href=/ja/docs/get-started><span>Get Started</span></a></li><li class=nav-item><a class=nav-link href=/ja/docs/user-guide/01-intro/><span>Docs</span></a></li><li class=nav-item><a class=nav-link href=/ja/posts><span>Blogs</span></a></li><li class=nav-item><a class=nav-link href=/ja/docs/benchmarks><span>Benchmarks</span></a></li><li class=nav-item><a class=nav-link href=/ja/talks><span>Talks</span></a></li><li class=nav-item><a class=nav-link href=https://github.com/fireducks-dev/fireducks/issues target=_blank rel=noopener><span>Report Issue</span></a></li><li class=nav-item><a class=nav-link href=/ja/docs/about-us><span>About Us</span></a></li><li class="nav-item dropdown d-none d-lg-block"><div class=dropdown><a class="nav-link dropdown-toggle" href=# role=button data-bs-toggle=dropdown aria-haspopup=true aria-expanded=false>Japanese</a><ul class=dropdown-menu><li><a class=dropdown-item href=/>English</a></li></ul></div></li></ul></div><div class="d-none d-lg-block"></div></div></nav></header><div class="container-fluid td-outer"><div class=td-main><div class="row flex-xl-nowrap"><aside class="col-12 col-md-3 col-xl-2 td-sidebar d-print-none"><div id=td-sidebar-menu class=td-sidebar__inner><form class="td-sidebar__search d-flex align-items-center"><button class="btn btn-link td-sidebar__toggle d-md-none p-0 ms-3 fas fa-bars" type=button data-bs-toggle=collapse data-bs-target=#td-section-nav aria-controls=td-section-nav aria-expanded=false aria-label="Toggle section navigation"></button></form><nav class="td-sidebar-nav collapse" id=td-section-nav><div class="td-sidebar-nav__section nav-item dropdown d-block d-lg-none"><div class=dropdown><a class="nav-link dropdown-toggle" href=# role=button data-bs-toggle=dropdown aria-haspopup=true aria-expanded=false>Japanese</a><ul class=dropdown-menu><li><a class=dropdown-item href=/>English</a></li></ul></div></div><ul class="td-sidebar-nav__section pe-md-3 ul-0"><li class="td-sidebar-nav__section-title td-sidebar-nav__section with-child active-path" id=m-japosts-li><a href=/ja/posts/ class="align-left ps-0 td-sidebar-link td-sidebar-link__section tree-root" id=m-japosts><span>Posts</span></a><ul class=ul-1><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child active-path" id=m-japosts2024-12-19-araki-li><a href=/ja/posts/2024-12-19-araki/ class="align-left ps-0 active td-sidebar-link td-sidebar-link__page" id=m-japosts2024-12-19-araki><span class=td-sidebar-nav-active-item>GPU版開発におけるpandasとの互換性確保</span></a></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-japostsbeginner_guide-li><a href=/ja/posts/beginner_guide/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-japostsbeginner_guide><span>FireDucksが遅いと思ったら</span></a></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-japosts2024-05-27-note10-li><a href=https://note.com/fireducks/n/n9d169e9054ed target=_blank rel=noopener class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-japosts2024-05-27-note10><i class="fa fa-external-link"></i><span>pandasを用いた大規模データの前処理をfireducksに置き換えてみる</span></a></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-japosts2024-05-20-note09-li><a href=https://note.com/fireducks/n/necfbb2dfdb84 target=_blank rel=noopener class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-japosts2024-05-20-note09><i class="fa fa-external-link"></i><span>生成AIとデータフレーム高速化技術を組み合わせたら、データ分析が爆楽になった話</span></a></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-japosts2024-05-13-note08-li><a href=https://note.com/fireducks/n/n4dd370647766 target=_blank rel=noopener class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-japosts2024-05-13-note08><i class="fa fa-external-link"></i><span>Pandasを高速化方法比較</span></a></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-japosts2024-05-08-note07-li><a href=https://note.com/fireducks/n/na95cf890f13b target=_blank rel=noopener class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-japosts2024-05-08-note07><i class="fa fa-external-link"></i><span>どれくらいスピードアップしたのか</span></a></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-japosts2024-04-22-note06-li><a href=https://note.com/fireducks/n/nd79ee805d99a target=_blank rel=noopener class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-japosts2024-04-22-note06><i class="fa fa-external-link"></i><span>FireDucks と Polarsを比較してみた</span></a></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-japosts2024-04-15-note05-li><a href=https://note.com/fireducks/n/na7484ce210f0 target=_blank rel=noopener class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-japosts2024-04-15-note05><i class="fa fa-external-link"></i><span>FireDucks性能評価</span></a></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-japosts2024-04-09-note04-li><a href=https://note.com/fireducks/n/n604974763502 target=_blank rel=noopener class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-japosts2024-04-09-note04><i class="fa fa-external-link"></i><span>pandasの代替案: Fireducks,Vaex, Polars, Modinを徹底比較！どれが最適？</span></a></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-japosts2024-04-01-note03-li><a href=https://note.com/fireducks/n/na5fde86c0ba3 target=_blank rel=noopener class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-japosts2024-04-01-note03><i class="fa fa-external-link"></i><span>AWS GlueでFireDucksを使ってPandasを高速化する</span></a></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-japosts2024-03-22-note02-li><a href=https://note.com/fireducks/n/nb5cabbe9236e target=_blank rel=noopener class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-japosts2024-03-22-note02><i class="fa fa-external-link"></i><span>FireDucks入門: 学習コストゼロでpandasを超えるパフォーマンスを手に入れる!</span></a></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-japosts2024-03-15-note-li><a href=https://note.com/fireducks/n/nee73e753df26 target=_blank rel=noopener class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-japosts2024-03-15-note><i class="fa fa-external-link"></i><span>pandas高速化の新星、FireDucksに迫る</span></a></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-japosts2023-12-24-ishizaka-li><a href=https://qiita.com/iszk1215/items/4916799360bfafd57bc4 target=_blank rel=noopener class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-japosts2023-12-24-ishizaka><i class="fa fa-external-link"></i><span>FireDucks vs Polars 42勝24敗！ あなたはどっちを使ってpandasを高速化する！？</span></a></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-japosts2023-12-20-daido-li><a href=https://qiita.com/shu_ohm1/items/33642646f5c055066cfe target=_blank rel=noopener class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-japosts2023-12-20-daido><i class="fa fa-external-link"></i><span>FireDucks に隠し機能を作ろうと思ったけどボツになった話</span></a></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-japosts2023-12-18-araki-li><a href=https://qiita.com/takuya-araki/items/38c3554ba72c9eb274ba target=_blank rel=noopener class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-japosts2023-12-18-araki><i class="fa fa-external-link"></i><span>FireDucksにおける最適化処理の紹介</span></a></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-japosts2023-12-15-ishizaka-li><a href=https://qiita.com/iszk1215/items/2c6385fa575de378a619 target=_blank rel=noopener class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-japosts2023-12-15-ishizaka><i class="fa fa-external-link"></i><span>FireDucksを支える技術</span></a></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-japosts2023-12-08-ohno-li><a href=https://qiita.com/ysyk-ohno/items/ddaaeca630d741a78f14 target=_blank rel=noopener class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-japosts2023-12-08-ohno><i class="fa fa-external-link"></i><span>FireDucks の GroupBy アルゴリズム切替えについての解説</span></a></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-japostsest-li><a href=/ja/posts/est/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-japostsest><span>FireDucks内部で働く高速化技術</span></a></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-japosts2023-12-04-ishizaka-li><a href=https://qiita.com/iszk1215/items/abe7621d9f6754de690a target=_blank rel=noopener class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-japosts2023-12-04-ishizaka><i class="fa fa-external-link"></i><span>FireDucksのご紹介</span></a></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-japosts2023-12-01-daido-li><a href=https://qiita.com/shu_ohm1/items/b0a35cfb4fce5b71c715 target=_blank rel=noopener class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-japosts2023-12-01-daido><i class="fa fa-external-link"></i><span>FireDucks のインポートフック機能にまつわるエトセトラ</span></a></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-japostsimporthook-li><a href=/ja/posts/importhook/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-japostsimporthook><span>インポートフック：ソースコードを書き換えずに FireDucks を使う方法のご紹介</span></a></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-japostsnes_taxi-li><a href=/ja/posts/nes_taxi/ class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-japostsnes_taxi><span>Pythonの高速データフレームライブラリFireDucksを使ってみた</span></a></li><li class="td-sidebar-nav__section-title td-sidebar-nav__section without-child" id=m-japoststtdc-li><a href=https://jpn.nec.com/rd/technologies/202312/index.html target=_blank rel=noopener class="align-left ps-0 td-sidebar-link td-sidebar-link__page" id=m-japoststtdc><i class="fa fa-external-link"></i><span>導入事例：トヨタテクニカルディベロップメント株式会社様 「Spicy MINT」</span></a></li></ul></li></ul></nav></div></aside><aside class="d-none d-xl-block col-xl-2 td-sidebar-toc d-print-none"><div class="td-page-meta ms-2 pb-1 pt-2 mb-0"></div><div class=td-toc><nav id=TableOfContents><ul><li><a href=#結果の型が異なる>結果の型が異なる</a></li><li><a href=#欠損値の演算における扱いが異なる>欠損値の演算における扱いが異なる</a></li><li><a href=#mergeの結果が異なる>mergeの結果が異なる</a></li></ul></nav></div></aside><main class="col-12 col-md-9 col-xl-8 ps-md-5 pe-md-4" role=main><a class=td-rss-button title=RSS href=https://fireducks-dev.github.io/ja/posts/index.xml target=_blank rel=noopener><i class="fa-solid fa-rss" aria-hidden=true></i></a><div class=td-content><h1>GPU版開発におけるpandasとの互換性確保</h1><div class="td-byline mb-4"><time datetime=2024-12-19 class=text-muted>Thursday, December 19, 2024</time></div><header class=article-meta></header><p>現在，FireDucksのGPU版の開発を進めています．</p><p>FireDucksは，プログラムを実行時に中間言語に変換し，この中間言語上で最適化を行った後，中間言語をバックエンド向けにコンパイルし，実行するアーキテクチャになっています．現在公開されているCPU版FireDucksでは，このバックエンドがCPU向けになっています．GPU版の開発においては，バックエンドをGPUに変更します．これにより，CPU版向けに開発してきた中間言語への変換や最適化をそのまま利用することができます．</p><p>GPU版バックエンドの開発には，NVIDIAのcuDFというライブラリを活用しています．我々の中間言語はpandasのAPIにおおむね対応しており，cuDFはpandasと類似したAPIを提供しているため，バックエンドの開発は一見容易に見えます．しかし，cuDFが提供する機能はpandasとは微妙に異なるため，pandasとの互換性を保つためには工夫が必要です．</p><p>今回のブログ記事では，pandasとの互換性を保つためにどのような点に課題があるか，一部ですが簡単に紹介したいと思います．</p><h2 id=結果の型が異なる>結果の型が異なる</h2><p>pandasで日付を扱う場合，datetime64型に変換しておくと，dtというアクセサを使って年や月，日を取り出すことができます．</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>df <span style=color:#f92672>=</span> pd<span style=color:#f92672>.</span>DataFrame({<span style=color:#e6db74>&#34;a&#34;</span>: [<span style=color:#e6db74>&#34;2017-11-01 12:24:00&#34;</span>]})
</span></span><span style=display:flex><span>dfa <span style=color:#f92672>=</span> pd<span style=color:#f92672>.</span>to_datetime(df[<span style=color:#e6db74>&#34;a&#34;</span>])
</span></span><span style=display:flex><span>print(dfa<span style=color:#f92672>.</span>dt<span style=color:#f92672>.</span>year)
</span></span></code></pre></div><p>とすると<code>2017</code>が返ってきます．ところでこの値の型は何でしょうか？
<code>print(dfa.dt.year.dtype)</code>
とすると，pandasでは<code>int32</code>，cuDfでは<code>int16</code>が返ってきます．この違いはGPUのメモリ利用量を減らすための，意図的なものであるようです．</p><p>年が16bitの値を越えることはないでしょうし，大きな問題は無いように見えますが，演算に使うとオーバーフローして結果が変わる可能性があります．例えば，0年からの時間数を求めようとして，
<code>dfa.dt.year * 365 * 24</code>
などとしてしまうと，int16ではオーバーフローするため異なる結果が出てしまいます．</p><p>この例に限らず，cuDFでは結果の型が微妙に異なることがよくあります．FireDucksではpandasとの互換性を保つため，同じ型になるように変換しています．</p><h2 id=欠損値の演算における扱いが異なる>欠損値の演算における扱いが異なる</h2><p>pandasでは欠損値(RDBで言うところのNULL)は基本的にNaNで表現されています．一方，cuDFでは欠損値は特別な値(NA)として扱われています．そのため，演算結果が異なることがあります．</p><p>例えば，</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>df <span style=color:#f92672>=</span> pd<span style=color:#f92672>.</span>Series([<span style=color:#ae81ff>1.0</span>, <span style=color:#ae81ff>3.0</span>, np<span style=color:#f92672>.</span>nan])
</span></span><span style=display:flex><span>mask <span style=color:#f92672>=</span> df <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>2.0</span>
</span></span><span style=display:flex><span>print (mask)
</span></span></code></pre></div><p>などとすると，pandasでは</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#ae81ff>0</span>     <span style=color:#66d9ef>True</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>1</span>    <span style=color:#66d9ef>False</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>2</span>    <span style=color:#66d9ef>False</span>
</span></span></code></pre></div><p>と欠損値の所にFalseが入ります．これはnp.nanとの比較になるためです．一方，cuDFでは</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#ae81ff>0</span>     <span style=color:#66d9ef>True</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>1</span>    <span style=color:#66d9ef>False</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>2</span>     <span style=color:#f92672>&lt;</span>NA<span style=color:#f92672>&gt;</span>
</span></span></code></pre></div><p>と演算結果も欠損値(NA)になります．RDBではNULLとの演算は常にNULLになるため，RDBの演算結果とは一致しているのですが，pandasとは一致していません．これもcuDFの仕様として意図的なものではないかと思います．</p><p>pandasも欠損値として特別な値(pd.NA)が実験的に取り入れられており，これを用いる場合はcuDFやRDBと同じ結果になるのですが，そうでない場合は結果が異なることになります．FireDucksでは欠損値の処理結果の扱いをpandasと同じになるよう，結果を調整しています．</p><h2 id=mergeの結果が異なる>mergeの結果が異なる</h2><p>pandasのmergeには複雑な仕様があり，cuDFは必ずしもその仕様に準拠していないようです．将来的には変更されるかも知れませんが，現在は例えば下記のような違いがあります．</p><p>pandasのmergeでは，mergeに用いる列の指定に<code>left_on</code>や<code>right_on</code>を使います．通常ここには列名を指定しますが，indexに名前がついている場合，index名を指定することもできます．また，<code>left_index=True</code>や<code>right_index=True</code>を指定することでもindexを指定することができます．では，これらの機能を使ってmergeを行ってみましょう．</p><p>まず，mergeするためのDataFrameを作成します．左側は</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>idx1 <span style=color:#f92672>=</span> pd<span style=color:#f92672>.</span>Index([<span style=color:#ae81ff>1</span>,<span style=color:#ae81ff>2</span>,<span style=color:#ae81ff>3</span>,<span style=color:#ae81ff>4</span>],name<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;p&#34;</span>)
</span></span><span style=display:flex><span>df1 <span style=color:#f92672>=</span> pd<span style=color:#f92672>.</span>DataFrame([[<span style=color:#ae81ff>1</span>,<span style=color:#ae81ff>2</span>],[<span style=color:#ae81ff>3</span>,<span style=color:#ae81ff>4</span>],[<span style=color:#ae81ff>5</span>,<span style=color:#ae81ff>6</span>],[<span style=color:#ae81ff>7</span>,<span style=color:#ae81ff>8</span>]], columns<span style=color:#f92672>=</span>[<span style=color:#e6db74>&#34;a&#34;</span>,<span style=color:#e6db74>&#34;b&#34;</span>], index<span style=color:#f92672>=</span>idx1)
</span></span></code></pre></div><p>で作成します．結果は</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>    a  b
</span></span><span style=display:flex><span> p
</span></span><span style=display:flex><span> <span style=color:#ae81ff>1</span>  <span style=color:#ae81ff>1</span>  <span style=color:#ae81ff>2</span>
</span></span><span style=display:flex><span> <span style=color:#ae81ff>2</span>  <span style=color:#ae81ff>3</span>  <span style=color:#ae81ff>4</span>
</span></span><span style=display:flex><span> <span style=color:#ae81ff>3</span>  <span style=color:#ae81ff>5</span>  <span style=color:#ae81ff>6</span>
</span></span><span style=display:flex><span> <span style=color:#ae81ff>4</span>  <span style=color:#ae81ff>7</span>  <span style=color:#ae81ff>8</span>
</span></span></code></pre></div><p>です．</p><p>右側は</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>idx2 <span style=color:#f92672>=</span> pd<span style=color:#f92672>.</span>Index([<span style=color:#ae81ff>1</span>,<span style=color:#ae81ff>2</span>,<span style=color:#ae81ff>5</span>,<span style=color:#ae81ff>6</span>],name<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;q&#34;</span>)
</span></span><span style=display:flex><span>df2 <span style=color:#f92672>=</span> pd<span style=color:#f92672>.</span>DataFrame([[<span style=color:#ae81ff>3</span>,<span style=color:#ae81ff>4</span>],[<span style=color:#ae81ff>5</span>,<span style=color:#ae81ff>6</span>],[<span style=color:#ae81ff>1</span>,<span style=color:#ae81ff>2</span>],[<span style=color:#ae81ff>3</span>,<span style=color:#ae81ff>4</span>]], columns<span style=color:#f92672>=</span>[<span style=color:#e6db74>&#34;c&#34;</span>,<span style=color:#e6db74>&#34;d&#34;</span>], index<span style=color:#f92672>=</span>idx2)
</span></span></code></pre></div><p>で作成します．結果は</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>   c  d
</span></span><span style=display:flex><span>q
</span></span><span style=display:flex><span><span style=color:#ae81ff>1</span>  <span style=color:#ae81ff>3</span>  <span style=color:#ae81ff>4</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>2</span>  <span style=color:#ae81ff>5</span>  <span style=color:#ae81ff>6</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>5</span>  <span style=color:#ae81ff>1</span>  <span style=color:#ae81ff>2</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>6</span>  <span style=color:#ae81ff>3</span>  <span style=color:#ae81ff>4</span>
</span></span></code></pre></div><p>です．</p><p>では，これらをmergeしてみましょう．左側は<code>left_on=["p"]</code>でindex列を名前で指定し，右側は<code>right_index=True</code>でindex列を使うことを指定しています．howには"outer"を指定してRDBで言うouter joinを行っています．</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>df1<span style=color:#f92672>.</span>merge(df2, left_on<span style=color:#f92672>=</span>[<span style=color:#e6db74>&#34;p&#34;</span>], right_index<span style=color:#f92672>=</span><span style=color:#66d9ef>True</span>, how<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;outer&#34;</span>)
</span></span></code></pre></div><p>結果はpandasの場合，</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>     p    a    b    c    d
</span></span><span style=display:flex><span><span style=color:#ae81ff>1.0</span>  <span style=color:#ae81ff>1</span>  <span style=color:#ae81ff>1.0</span>  <span style=color:#ae81ff>2.0</span>  <span style=color:#ae81ff>3.0</span>  <span style=color:#ae81ff>4.0</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>2.0</span>  <span style=color:#ae81ff>2</span>  <span style=color:#ae81ff>3.0</span>  <span style=color:#ae81ff>4.0</span>  <span style=color:#ae81ff>5.0</span>  <span style=color:#ae81ff>6.0</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>3.0</span>  <span style=color:#ae81ff>3</span>  <span style=color:#ae81ff>5.0</span>  <span style=color:#ae81ff>6.0</span>  NaN  NaN
</span></span><span style=display:flex><span><span style=color:#ae81ff>4.0</span>  <span style=color:#ae81ff>4</span>  <span style=color:#ae81ff>7.0</span>  <span style=color:#ae81ff>8.0</span>  NaN  NaN
</span></span><span style=display:flex><span>NaN  <span style=color:#ae81ff>5</span>  NaN  NaN  <span style=color:#ae81ff>1.0</span>  <span style=color:#ae81ff>2.0</span>
</span></span><span style=display:flex><span>NaN  <span style=color:#ae81ff>6</span>  NaN  NaN  <span style=color:#ae81ff>3.0</span>  <span style=color:#ae81ff>4.0</span>
</span></span></code></pre></div><p>cuDFの場合，</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>         a     b     c     d
</span></span><span style=display:flex><span>p
</span></span><span style=display:flex><span><span style=color:#ae81ff>1</span>        <span style=color:#ae81ff>1</span>     <span style=color:#ae81ff>2</span>     <span style=color:#ae81ff>3</span>     <span style=color:#ae81ff>4</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>2</span>        <span style=color:#ae81ff>3</span>     <span style=color:#ae81ff>4</span>     <span style=color:#ae81ff>5</span>     <span style=color:#ae81ff>6</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>3</span>        <span style=color:#ae81ff>5</span>     <span style=color:#ae81ff>6</span>  <span style=color:#f92672>&lt;</span>NA<span style=color:#f92672>&gt;</span>  <span style=color:#f92672>&lt;</span>NA<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>4</span>        <span style=color:#ae81ff>7</span>     <span style=color:#ae81ff>8</span>  <span style=color:#f92672>&lt;</span>NA<span style=color:#f92672>&gt;</span>  <span style=color:#f92672>&lt;</span>NA<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>&lt;</span>NA<span style=color:#f92672>&gt;</span>  <span style=color:#f92672>&lt;</span>NA<span style=color:#f92672>&gt;</span>  <span style=color:#f92672>&lt;</span>NA<span style=color:#f92672>&gt;</span>     <span style=color:#ae81ff>1</span>     <span style=color:#ae81ff>2</span>
</span></span><span style=display:flex><span><span style=color:#f92672>&lt;</span>NA<span style=color:#f92672>&gt;</span>  <span style=color:#f92672>&lt;</span>NA<span style=color:#f92672>&gt;</span>  <span style=color:#f92672>&lt;</span>NA<span style=color:#f92672>&gt;</span>     <span style=color:#ae81ff>3</span>     <span style=color:#ae81ff>4</span>
</span></span></code></pre></div><p>となります．欠損値と欠損値のある列の型が違うことはとりあえず良いとして(pandasでは欠損値にNaNを使うため，欠損値がある列はfloat64型になる），pandasには<code>p</code>という列がありますが，cuDFにはありません．また結果のindexの名前が異なっています．</p><p><code>p</code>は元々左側のDataFrameのindex列であり，これが結果のDataFrameの列として作成されるのは，奇妙な仕様のように思えます（<code>p</code>のような列が生成されるのは，上記のような特別なパラメータの組合せの場合にのみ起こります）．RDBのjoinではこのような列は作成されません．一方で，結果は明らかに異なるため，ユーザプログラムの互換性上問題になる可能性があります．</p><p>FireDucksではこのような場合にもpandasとできるだけ同じ結果になるように調整しています．</p><p>以上のように，pandasとcuDFでは結果が異なる場合があります．FireDucksのGPU版ではこのような差異を吸収し，できるだけpandasと同じ結果が生成されるように実装を行っています．FireDucksのGPU版はまだ開発中でユーザの皆様が使える状態ではありませんが，開発が完了したら是非お試し頂ければと思います．</p><ul class="list-unstyled d-flex justify-content-between align-items-center mb-0 pt-5"><li><a href=/ja/posts/beginner_guide/ aria-label="前へ - FireDucksが遅いと思ったら" class="btn btn-primary"><span class=me-1>←</span>前へ</a></li><li><a class="btn btn-primary disabled">次へ<span class=ms-1>→</span></a></li></ul></div></main></div></div><footer class="td-footer row d-print-none"><div class=container-fluid><div class="row mx-md-2"><div class="col-6 col-sm-4 text-xs-center order-sm-2"><ul class=td-footer__links-list><li class=td-footer__links-item data-bs-toggle=tooltip title="Post issues on GitHub issues" aria-label="Post issues on GitHub issues"><a target=_blank rel=noopener href=https://github.com/fireducks-dev/fireducks aria-label="Post issues on GitHub issues"><i class="fa-brands fa-github"></i></a></li><li class=td-footer__links-item data-bs-toggle=tooltip title="Send an e-mail to us" aria-label="Send an e-mail to us"><a target=_blank rel=noopener href=mailto:contact@fireducks.jp.nec.com aria-label="Send an e-mail to us"><i class="fa-solid fa-envelope"></i></a></li><li class=td-footer__links-item data-bs-toggle=tooltip title="Follow us in X" aria-label="Follow us in X"><a target=_blank rel=noopener href=https://x.com/fireducksdev aria-label="Follow us in X"><i class="fa-brands fa-x-twitter"></i></a></li><li class=td-footer__links-item data-bs-toggle=tooltip title="Join us on Slack" aria-label="Join us on Slack"><a target=_blank rel=noopener href=https://join.slack.com/t/fireducks/shared_invite/zt-2j4lucmtj-IGR7AWlXO62Lu605pnBJ2w aria-label="Join us on Slack"><i class="fa-brands fa-slack"></i></a></li></ul></div><div class="col-6 col-sm-4 text-end text-xs-center order-sm-3"></div><div class="td-footer__copyright-etc col-12 col-sm-4 text-center py-2 order-sm-2"><span>&copy; 2024 FireDucks Dev Team All Rights Reserved</span></div></div></div></footer></div><script src=/js/main.min.350b703200e2632331b6ab5a6c71195d176b52e89c9b70db7c43764d40b28d92.js integrity="sha256-NQtwMgDiYyMxtqtabHEZXRdrUuicm3DbfEN2TUCyjZI=" crossorigin=anonymous></script><script defer src=/js/click-to-copy.min.f724d3de49218995223b7316aa2e53e2b34bf42026bf399ebb21bb02212402d1.js integrity="sha256-9yTT3kkhiZUiO3MWqi5T4rNL9CAmvzmeuyG7AiEkAtE=" crossorigin=anonymous></script><script src=/js/tabpane-persist.js></script></body></html>