var suggestions=document.getElementById("suggestions"),search=document.getElementById("search");search!==null&&document.addEventListener("keydown",inputFocus);function inputFocus(e){e.ctrlKey&&e.key==="/"&&(e.preventDefault(),search.focus()),e.key==="Escape"&&(search.blur(),suggestions.classList.add("d-none"))}document.addEventListener("click",function(e){var t=suggestions.contains(e.target);t||suggestions.classList.add("d-none")}),document.addEventListener("keydown",suggestionFocus);function suggestionFocus(e){const s=suggestions.classList.contains("d-none");if(s)return;const t=[...suggestions.querySelectorAll("a")];if(t.length===0)return;const n=t.indexOf(document.activeElement);if(e.key==="ArrowUp"){e.preventDefault();const s=n>0?n-1:0;t[s].focus()}else if(e.key==="ArrowDown"){e.preventDefault();const s=n+1<t.length?n+1:n;t[s].focus()}}(function(){var e=new FlexSearch.Document({tokenize:"forward",cache:100,document:{id:"id",store:["href","title","description"],index:["title","description","content"]}});e.add({id:0,href:"/en/docs/get-started/",title:"Get Started",description:"",content:""}),e.add({id:1,href:"/en/docs/get-started/get-started/",title:"Get Started",description:`FireDucks beta is released on pypi.org under the 3-Clause BSD License (the Modified BSD License).
Install #pip install fireducks Usage #FireDucks provides two types of usage: Import Hook and Explicit Import.
Import Hook #FireDucks provides a utility module fireducks.imhook. This module runs the given Python script by automatically replacing import pandas statement with import fireducks.pandas. It is typically used with Python interpreter\u0026rsquo;s -m option as follows. This module enables you to use FireDucks for your existing program as it is.`,content:`FireDucks beta is released on pypi.org under the 3-Clause BSD License (the Modified BSD License).
Install #pip install fireducks Usage #FireDucks provides two types of usage: Import Hook and Explicit Import.
Import Hook #FireDucks provides a utility module fireducks.imhook. This module runs the given Python script by automatically replacing import pandas statement with import fireducks.pandas. It is typically used with Python interpreter\u0026rsquo;s -m option as follows. This module enables you to use FireDucks for your existing program as it is.
python3 -m fireducks.imhook your_script.py This is very useful when your program includes many Python scripts which import pandas internally. You don\u0026rsquo;t need to replace individual import statements from those scripts manually.
Explicit Import #FireDucks has pandas-like module fireducks.pandas which can be imported instead of pandas. If you want to use FireDucks for an existing pandas program, replace the import statement as follows.
# import pandas as pd import fireducks.pandas as pd This might be useful when you will use FireDucks on Jupyter notebook.
`}),e.add({id:2,href:"/en/docs/user-guide/",title:"User Guide",description:"Useful information for FireDucks users",content:""}),e.add({id:3,href:"/en/docs/user-guide/01-intro/",title:"Introduction",description:`FireDucks has the same API as in pandas, so you can refer to the pandas documentation and articles to get started, or you can use LLM to output pandas code and run it in FireDucks.
This user guide is intended for those who want to learn more about FireDucks, explaining its inner workings and what is useful to know about it. In particular, the following points may seem strange to those who are familiar with pandas.`,content:`FireDucks has the same API as in pandas, so you can refer to the pandas documentation and articles to get started, or you can use LLM to output pandas code and run it in FireDucks.
This user guide is intended for those who want to learn more about FireDucks, explaining its inner workings and what is useful to know about it. In particular, the following points may seem strange to those who are familiar with pandas.
Execution model For those who are used to pandas, the difference between the execution model of pandas and FireDucks may be a concern. In that case, please read Execution Model. pandas compatibility This section describes pandas compatibility from the perspective of compatibility, which is not the goal of FireDucks. Using external libraries Due to the incompatibility that FireDucks does not aim for, FireDucks data may not work when passed to a library that accepts pandas data. In such cases, the data can be converted to pandas data. `}),e.add({id:4,href:"/en/docs/user-guide/02-exec-model/",title:"Execution Model",description:"execution model",content:`The execution model of FireDucks differs from that of pandas. pandas is an eager execution model in which the process is executed immediately upon method invocation, while FireDucks is a lazy execution model in which the process is executed in batches when the results are needed.
Lazy execution model #The following figure shows the execution images of pandas and FireDucks.
In pandas, for example, calling the read_csv method reads data from a CSV file. FireDucks, on the other hand, only generates an intermediate language equivalent to read_csv, but does not read the data. Therefore, the line df = pd.read_csv(\u0026quot;data.csv\u0026quot;) ends immediately in FireDucks.
Thus, the main methods of FireDucks do not actually process the data frame, but generate the intermediate language. Each time a method is called, more and more intermediate language is generated, and when the result is needed (e.g., when writing to a csv file), the previously generated intermediate language is executed all at once.
FireDucks performs actual execution at the following points
Saving to a file (DataFrame.to_csv, DataFrame.to_parquet, etc.) Displaying a data frame (print(df), etc.) Because of these differences in execution models, those familiar with pandas may find that time-consuming methods finish in a fraction of a second, or that saving to a csv file takes longer than expected.
About time measurement #FireDucks performs delayed execution, so if you want to measure the actual processing time for each method, you need to be a little creative.
For example, if you measure the time as follows, the last interval (t3 - t2) will include the time of all processes.
t0 = time.time() df = pd.read_csv(\u0026quot;data.csv\u0026quot;) t1 = time.time() df = df.sort_values(\u0026quot;a\u0026quot;) t2 = time.time() df.to_csv(\u0026quot;sorted.csv\u0026quot;) t3 = time.time() To work around this, call FireDucks\u0026rsquo; own method _evaluate for immediate execution.
t0 = time.time() df = pd.read_csv(\u0026quot;data.csv\u0026quot;)._evaluate() t1 = time.time() df = df.sort_values(\u0026quot;a\u0026quot;)._evaluate() t2 = time.time() df.to_csv(\u0026quot;sorted.csv\u0026quot;)._evaluate() t3 = time.time() Note, however, that this will result in a fragmented execution, which will prevent FireDucks from optimizing multiple operations at once. Therefore, it is recommended that you use _evaluate only to measure the time of individual methods.
`}),e.add({id:5,href:"/en/docs/user-guide/03-acceleration/",title:"Acceleration in FireDucks",description:`There are two mechanisms to accelerate FireDucks. The first is compiler optimization on the IR, intermediate representation, and the second is multithreading on the backend.
Compiler Optimization #FireDucks uses a runtime compiler mechanism to convert Python programs into an intermediate language before execution. Optimization on the intermediate language means that the Python program is converted to an intermediate language that can be executed faster without changing the meaning of the program, rather than being executed as-is.`,content:`There are two mechanisms to accelerate FireDucks. The first is compiler optimization on the IR, intermediate representation, and the second is multithreading on the backend.
Compiler Optimization #FireDucks uses a runtime compiler mechanism to convert Python programs into an intermediate language before execution. Optimization on the intermediate language means that the Python program is converted to an intermediate language that can be executed faster without changing the meaning of the program, rather than being executed as-is. This is equivalent to automatically performing the kind of tuning that a skilled programmer would perform when writing a program.
The FireDucks intermediate language is an intermediate language designed specifically for DataFrames, and each instruction in the intermediate language is a highly abstract, information-rich instruction that represents an operation on a DataFrame. Therefore, the FireDucks compiler can understand the meaning of a program without complicated program analysis and can perform optimization specific to DataFrame.
Examples of Optimizations #Here is an example of such optimization. The following program extracts rows from a DataFrame in which column a is greater than 10, and then extracts column b from that row.
selected = df[df[\u0026quot;a\u0026quot;] \u0026gt; 10][\u0026quot;b\u0026quot;] This is a commonly used process, and the code looks straightforward. However, the process of extracting the first row covers all columns, which is not efficient if df has more columns than just a and b. Because DataFrames generally use column-oriented data structures, the process of extracting a specific row is a much more time-consuming process than extracting a column, and doing so for all columns may result in non-negligible overhead.
FireDucks optimization uses such domain knowledge to transform the intermediate language so that column extraction is performed first. The transformed process, written in Python, looks like the following code.
tmp = df[[\u0026quot;a\u0026quot;, \u0026quot;b\u0026quot;]] selected = tmp[df[\u0026quot;a\u0026quot;] \u0026gt; 10][\u0026quot;b\u0026quot;]] While skilled users who are aware of DataFrame\u0026rsquo;s internal data structures will prefer code like this, FireDucks performs this acceleration as an optimization on an intermediate language.
Multithreading #In FireDucks, the user API and its execution are completely independent of each other via an intermediate language. The backend executes the instructions of the intermediate language and has the ability to perform specific data structures and operations on data frames.
FireDucks allows the backend to be changed, for example, a backend tuned for multi-core, a backend using accelerators such as GPUs, etc., to match the target environment, thereby increasing speed. The backend can be changed by environment variables, allowing the user to switch backends without changing the user program at all.
FireDucks Beta includes a multi-threaded backend for CPUs. This backend uses Apache Arrow as the data structure and adds its own parallelization in addition to the data frame operations provided by Apache Arrow.
`}),e.add({id:6,href:"/en/docs/user-guide/04-compatibility/",title:"pandas compatibility",description:`FireDucks provides the same API (class names, method names, and attribute names) as pandas, and aims for compatibility in terms of being able to use it simply by changing import statements.
Compatibility Concept #We do not aim for compatibility in the following aspects.
Complete consistency of class names FireDucks provides a pandas-compatible API in the module fireducks.pandas. The complete class names, including module names, are different from those of pandas.`,content:`FireDucks provides the same API (class names, method names, and attribute names) as pandas, and aims for compatibility in terms of being able to use it simply by changing import statements.
Compatibility Concept #We do not aim for compatibility in the following aspects.
Complete consistency of class names FireDucks provides a pandas-compatible API in the module fireducks.pandas. The complete class names, including module names, are different from those of pandas. For example, the data frame type is pandas.DataFrame in pandas, but fireducks.pandas.DataFrame in FireDucks, which are not exactly the same. Therefore, an explicit test for a pandas DataFrame, such as isinstance(df, pandas.DataFrame), will be false. True for import fireducks.pandas as pd; isinstance(df, pd.DataFrame). Full compatibility of errors and warnings Because of delayed execution, the timing of errors and warnings in FireDucks is different from that in pandas. It is not the goal to match error messages (although the goal is to match Exception classes). In addition, since Warnings may not be necessary in FireDucks, whether or not a Warning is generated may not match pandas. Complete reproduction of undefined behavior and bugs in pandas. We do not aim to reproduce the implementation-dependent behavior of pandas. In particular, it may be undefined whether pandas returns a copy or a reference, and we do not recommend writing code that depends on either (reference). pandas internal API and Experimental features We do not aim to provide methods that begin with an underscore (_) or features that are marked as Experimental in the pandas documentation. Extending pandas Functions that extend pandas as described in Extending pandas are currently not targeted. These include the ability to create subclasses of DataFrames and Series, and the ability to define your own data types. Consistency of the order of merge/join result rows with pandas The order of rows in merge/join results may not match the order in pandas. Sorting will match. Use with pandas #The internal API and isinstance are frequently used in pandas. Therefore, using FireDucks with pandas will not work in most cases. It is recommended to rewrite all import statements or use automatic conversion by import hook to use FireDucks instead.
If for some reason you wish to use FireDucks with pandas or pass DataFrame or Series of FireDucks to a library that accepts those of pandas, please use the pandas conversion function.
import somelib import fireducks.pandas as pd df = pd.read_csv(...) somelib.process_pandas_dataframe(df.to_pandas()) `}),e.add({id:7,href:"/en/docs/user-guide/05-api/",title:"FireDucks Own API",description:`FireDucks has its own API that some pandas do not have. Here are some of them.
pandas conversion #FireDucks DataFrame/Series has a to_pandas method that allows conversion to pandas data. This is useful, for example, when using an external library that accepts pandas data.
Also, fireducks.pandas.from_pandas can be used to convert pandas DataFrames/Series to FireDucks.
Explicit intermediate language execution #FireDucks provides lazy execution. Lazy execution allows multiple APIs to be executed at once and is an important feature for speeding up the process through optimization on intermediate languages.`,content:`FireDucks has its own API that some pandas do not have. Here are some of them.
pandas conversion #FireDucks DataFrame/Series has a to_pandas method that allows conversion to pandas data. This is useful, for example, when using an external library that accepts pandas data.
Also, fireducks.pandas.from_pandas can be used to convert pandas DataFrames/Series to FireDucks.
Explicit intermediate language execution #FireDucks provides lazy execution. Lazy execution allows multiple APIs to be executed at once and is an important feature for speeding up the process through optimization on intermediate languages.
On the other hand, when you want to measure the execution time of individual APIs, such as when verifying the operation of FireDucks, you will need to be creative; most APIs in FireDucks only generate an intermediate language, so they are completed in a very short time, and measuring before and after API calls does not allow you to measure the actual data frame processing time. Therefore, it is not possible to measure the actual data frame processing time by measuring the time before and after the API call.
In such cases, the DataFrame._evaluate method can be used to explicitly execute the API. When _evaluate is called, it executes the intermediate language for the DataFrame that has been created up to that point in time. Therefore, by calling _evaluate before and after the process you want to measure, you can measure the actual processing time.
An example of groupby time measurement is shown below.
df = pd.read_csv(...)._evaluate() # end read_csv so that it is not in the measurement range t0 = time.time() # start measuring time g = df.groupby(...).sum()._evaluate() # immediately after generating intermediate language for groupby t1 = time.time() # end of time measurement API for feature generation #One of the applications of data frames is feature generation, which is a pre-processing step in machine learning. In feature generation, data frames are processed in various ways to generate features for training in order to create better models, which can be very time-consuming.
FireDucks also provides an API for fast feature generation. Currently, the following two features are typical feature generation methods. These features can be implemented using a combination of pandas APIs, but FireDucks provides them as APIs, and they are preoptimized to be fast, just as the FireDucks compiler does. See the API Doc for details on each API.
Aggregate features: fireducks.pandas.aggregate multi-target encoding: fireducks.pandas.multi_target_encoding `}),e.add({id:8,href:"/en/docs/user-guide/tips/",title:"Tips",description:`The know-how of pandas, such as avoiding loops and apply, is also useful for FireDucks. Here are some tips to improve performance in FireDucks.
Avoid loops #Looping out data from a DataFrame is slow, so it is better to use the DataFrame API as much as possible (this is also true for pandas).
For example, the following loop processes the elements of a Series one by one.
s = 0 for i in range(len(df)): if df[\u0026quot;A\u0026quot;].`,content:`The know-how of pandas, such as avoiding loops and apply, is also useful for FireDucks. Here are some tips to improve performance in FireDucks.
Avoid loops #Looping out data from a DataFrame is slow, so it is better to use the DataFrame API as much as possible (this is also true for pandas).
For example, the following loop processes the elements of a Series one by one.
s = 0 for i in range(len(df)): if df[\u0026quot;A\u0026quot;]. if df[\u0026quot;A\u0026quot;][i] \u0026gt; 2: s += df[\u0026quot;B\u0026quot;][i] \u0026gt; 2 s += df[\u0026quot;B\u0026quot;][i]. Using the API, you can write the following.
s = df[df[\u0026quot;A\u0026quot;] \u0026gt; 2][\u0026quot;B\u0026quot;].sum() The same applies to Dataframe.iterrows and so on.
Do not use apply #Passing user-defined functions such as DataFrame.apply is not currently supported by FireDucks\u0026rsquo; current optimizer that generates an intermediate language and compiles it.
Do not use attribute-style column references #Column references can be written as df[\u0026quot;A\u0026quot;] or df.A, but the latter may conflict with the original attributes of the DataFrame, so it is better to write df[\u0026quot;A\u0026quot;] in bracket format.
In FireDucks, the df.A format requires processing to determine whether A is a column name or not, which may result in loss of compiler optimization.
Do not use undefined behavior of pandas #Whether df[\u0026quot;A\u0026quot;] returns a reference or a copy in the following cases is undefined in pandas, but if it returns a copy, df is not updated. In many cases this will not be the intended behavior.
df[\u0026quot;A\u0026quot;][1] = 2 Such undefined behavior may work differently in FireDucks than in pandas, so what works in pandas may not work in FireDucks. It is better not to use undefined behavior.
In this example, it is safe to write the following. However, as mentioned above, element-by-element access is inefficient, so if another implementation is possible, it is better to use it.
df.iloc[1, 0] = 2 # if A is the first column Avoid Fallback #FireDucks has a feature called fallback that calls pandas internally. This is a feature to improve pandas compatibility by using pandas to perform functions not currently supported by FireDucks. On the other hand, this is a disadvantage in terms of execution time and memory usage, since it involves converting the FireDucks data structure to pandas, executing the pandas method, and then converting it to the FireDucks data structure again.
We are continuously working to reduce fallbacks, but it is also effective to improve performance by avoiding fallbacks in user programs. The environment variable FIREDUCKS_FLAGS=\u0026quot;-Wfallback\u0026quot; can be used to log when fallbacks occur.
`}),e.add({id:9,href:"/en/docs/benchmarks/",title:"Benchmarks",description:"Benchmarks",content:""}),e.add({id:10,href:"/en/docs/benchmarks/benchmarks/",title:"Benchmarks",description:`Here are the results of the comparison between FireDucks and pandas using TPCx-BB and TPC-H, benchmarks that include a lot of processing related to data analysis. The results are shown below.
These benchmarks include various data analysis workloads called queries. This comparison compares the pandas implementation of those queries with the FireDucks implementation using the FireDucks import hook. The graphs show a comparison of the FireDucks run using pandas versus FireDucks.`,content:`Here are the results of the comparison between FireDucks and pandas using TPCx-BB and TPC-H, benchmarks that include a lot of processing related to data analysis. The results are shown below.
These benchmarks include various data analysis workloads called queries. This comparison compares the pandas implementation of those queries with the FireDucks implementation using the FireDucks import hook. The graphs show a comparison of the FireDucks run using pandas versus FireDucks.
The graph shows how fast FireDucks is compared to pandas. The versions used in the comparison are as follows
pandas-2.0.1 fireducks-0.7.1 TPCx-BB #TPC-H #`}),e.add({id:11,href:"/en/docs/use-case/",title:"Use Cases",description:"Use cases of FireDucks",content:""}),e.add({id:12,href:"/en/docs/use-case/data-scientist/",title:"All Data Scientists",description:`As a data scientist, you want to minimize the complexity and latency of working with large data sets and increase your productivity. FireDucks can help you maximize your value as a data scientist.
Time is Money #Data preprocessing and analysis work can take up to 500 hours of waiting time each year. You can turn this time into time you can invest in other important tasks or new projects.`,content:`As a data scientist, you want to minimize the complexity and latency of working with large data sets and increase your productivity. FireDucks can help you maximize your value as a data scientist.
Time is Money #Data preprocessing and analysis work can take up to 500 hours of waiting time each year. You can turn this time into time you can invest in other important tasks or new projects.
Speedy hypothesis testing #Quick analysis cycles allow you to make decisions efficiently. The speed of business can be dramatically improved by smoothly rotating the cycle from hypothesis formulation to validation and re-examination.
Rapid machine learning models implementation #FireDucks is particularly effective in accelerating feature creation. They provide powerful support during the model building phase.
`}),e.add({id:13,href:"/en/docs/use-case/industries/",title:"Highly suitable use cases",description:`Automobile Industry #In recent years, cars have been equipped with technology that records information such as our driving history and brake strength in real time. This information is called \u0026ldquo;probe data\u0026rdquo;, and FireDucks and these data can be used to
Weather Prediction: Build a prediction model using wiper and outside temperature data. This will revolutionize the data business in the automotive industry.
Marketing: Helps you find the best locations for new store openings based on nearby parking lot usage.`,content:`Automobile Industry #In recent years, cars have been equipped with technology that records information such as our driving history and brake strength in real time. This information is called \u0026ldquo;probe data\u0026rdquo;, and FireDucks and these data can be used to
Weather Prediction: Build a prediction model using wiper and outside temperature data. This will revolutionize the data business in the automotive industry.
Marketing: Helps you find the best locations for new store openings based on nearby parking lot usage. And improve your customers\u0026rsquo; experience with faster marketing tools and real-time dashboard updates.
Traffic Improvements: Identify congested or hazardous sites and make recommendations to resolve them. Accidents can also be prevented, for example by adding signs to areas where emergency braking is common.
One caveat, however, is that FireDucks is currently limited in its ability to process very large data sets simultaneously on multiple servers. However, once the data is organized, FireDucks can be used to its full potential. This supports efficient and rapid implementation of innovative initiatives such as those described above.
Telecommunications Industry #FireDucks maximizes the potential of location-based businesses, which are expected to become even more valuable in the future.
Faster Location Information Processing: User location information is critical to the delivery of a wide range of services and features in the telecommunications industry. Faster processing of this information improves real-time performance and quality of service.
Rapid Service Response: Faster location-based services and information delivery reduces response time to end-users, resulting in improved user satisfaction and new services. This is expected to increase user satisfaction and expand new business opportunities.
Optimize edge computing: Optimize edge computing performance by processing location information in real time. Reduced communication latency enables smoother service delivery.
Develop new location-based services: Benefit from faster data processing and gain flexibility to develop new location-based services and features. This allows for quicker response to market needs.
Financial Industry #FireDucks provides solutions to make financial data processing more efficient and secure, where reliability and speed are essential.
High-speed processing of complex financial data: Daily trading data, customer information, market trends, and other large volumes of data require fast batch aggregation, and FireDucks can dramatically increase the speed of processing.
Stable service: Greatly reduces the risk of timeout errors, even when data processing increases due to new user growth or market fluctuations. Provide more reliable service to your customers.
Efficiently link to subsequent operations: Faster processing speeds allow for quicker data linkage to subsequent operations and other systems. This significantly reduces the risk of operational delays and errors by ensuring that the entire batch process is completed within the specified time.
Support for real-time decision making: In the financial industry, there are many situations where quick decision making is required. The ability to process and analyze data at high speed allows for more effective real-time analysis of market trends and risk management.
Cloud Hosting Industry #FireDucks can provide added value to cloud users who are concerned about latency and error risk in their daily batch aggregation processes.
Minimize Errors: Data processing times increase with the number of new users. However, our technology\u0026rsquo;s accelerated batch processing significantly reduces the timeout error rate. This allows us to continue to provide stable service.
Efficient task transitions: Tasks can be passed smoothly without making subsequent processes wait. These fast transitions shorten the overall batch processing completion time. The risk of a process not completing in time is greatly reduced.
Resource Optimization: Faster batch processing makes better use of required resources and reduces excessive costs. At the same time, processing efficiency reduces energy consumption, making it an economical and eco-friendly choice.
E-commerce Industry #With FireDucks, you can improve the efficiency of your recommendation engine, which directly leads to increased user satisfaction and sales.
Data-driven optimization: The output from a vast amount of information, such as customer gender, age, browsing history, click history, purchase history, etc., is critical data for recommending the best products for each individual customer. However, processing this data is extremely time-consuming. This is where FireDucks technology comes in.
Faster, more effective recommendations: FireDucks dramatically reduces data preprocessing time. This allows you to explore more advanced and effective recommendation engine algorithms that will not only improve your customers\u0026rsquo; buying experience, but will also significantly increase your sales.
Timely Marketing Initiatives: Reduced processing times allow for timely promotions and campaigns. The reduced processing time enables the development of timely promotions and campaigns that match the seasonality and trends, attracting the interest of customers and leading to immediate purchases.
Smartphone Game App Industry #FireDucks can be used to accelerate data analysis to prevent user abandonment and further increase sales.
User behavior analysis: At what stage of the game does a user leave, and what triggers the decision to pay? Finding the answers to these questions from data is the key to the success of a game. This information is hidden in a vast amount of data.
Measurement realization: FireDucks has dramatically accelerated the data analysis process. This allows data scientists to focus on analysis and to quickly consider and implement effective measures, such as the optimal timing for tutorials and when to offer free gachas. As a result, we can expect longer user dwell time and reduced abandonment rates.
Cloud cost reduction: The cost of data aggregation using AWS or GCP increases in proportion to the processing time. However, FireDucks\u0026rsquo; acceleration technology reduces this processing time, resulting in significant savings on cloud services.
Optimize the player experience: Rapid analytics allow you to optimize in-game activities and promotions in real time according to user behavior. This is expected to increase user satisfaction and encourage continuous billing.
`}),e.add({id:14,href:"/en/docs/release-note/",title:"Release Note",description:"FireDucks Release Note",content:""}),e.add({id:15,href:"/en/docs/release-note/release-note/",title:"Release Note",description:"FireDucks Release Note",content:`0.8.3 (Oct 26, 2023) #Add wheel package for python3.11 (tested with python-3.11.4 on ubuntu23.04). Improve performance of merge/join when both frames have default index. Improve pandas compatibility of methods which return a scalar value like Series.aggregate. Remove fallback: DataFrame.columns, DataFrame.pop, fireducks.pandas.join Add kernel tracing (enabled by \u0026ldquo;FIREDUCKS_FLAGS=\u0026ndash;trace=3\u0026rdquo;) Add reason to fallback log (enabled by \u0026ldquo;FIREDUCKS_FLAGS=-Wfallback\u0026rdquo;). 0.8.2 (Oct 19, 2023) #First public beta release `}),e.add({id:16,href:"/en/docs/about-us/",title:"About Us",description:"About us",content:""}),e.add({id:17,href:"/en/docs/about-us/about-us/",title:"About Us",description:"Who are we?",content:`FireDucks is developed by members of NEC\u0026rsquo;s R\u0026amp;D department who love acceleration.
We believe that acceleration has various values. In the age of cloud computing, the value is also increasing in the form of lower cloud costs and reduced CO2 emissions. Above all, it is a great feeling when a program you have written runs fast.
May the Acceleration be with you #FireDucks is still under research and development, and there are still many areas for parallelization and optimization that we would like to do. Nevertheless, we decided to release FireDucks to the public because we want everyone to use it and experience its speedup, and because we believe that we can create better technology only if many people use it.
FireDucks Development Team
mailto:contact@fireducks.jp.nec.com
`}),e.add({id:18,href:"/en/docs/help/",title:"Help",description:"Help FireDucks.",content:""}),e.add({id:19,href:"/en/docs/help/faq/",title:"FAQ",description:"Help on FireDucks.",content:" About the beta version Is FireDucks beta available for free? Yes Can I use FireDucks beta for commercial purposes? Yes Is FireDucks beta OSS? No About the release to manufacturing (RTM) version When will the RTM version of FireDucks be released? Not determined yet What will the license be applied for the RTM version of FireDucks? Not determined yet About supported platforms FireDucks is currently available for Linux (manylinux) on the x86_64 architecture. We will support Windows etc. if many requests. About support Is there support for FireDucks? As far as we know, no organization offers paid support for FireDucks. We are preparing a Discord server where the FireDucks development team and users discuss. I found a problem, who should I contact? Please register an issue on the GitHub repository. Or please email mailto:contact@fireducks.jp.nec.com. Can I send a request? Of course! We may not be able to respond to all requests, but all requests are welcome. Please see contact information. Where can I get release information for FireDucks? Please use release notifications on pypi.org. We will also post announcements on X (Twitter). "}),e.add({id:20,href:"/en/docs/help/contact/",title:"Contact",description:"FireDucks provides discord and e-mail as contact points",content:" Issues on GitHub X (Twitter) Discord (preparing) E-mail "}),e.add({id:21,href:"/en/docs/",title:"Docs",description:"Docs FireDucks.",content:""}),search.addEventListener("input",t,!0);function t(){const s=5;var n=this.value,o=e.search(n,{limit:s,enrich:!0});const t=new Map;for(const e of o.flatMap(e=>e.result)){if(t.has(e.doc.href))continue;t.set(e.doc.href,e.doc)}if(suggestions.innerHTML="",suggestions.classList.remove("d-none"),t.size===0&&n){const e=document.createElement("div");e.innerHTML=`No results for "<strong>${n}</strong>"`,e.classList.add("suggestion__no-results"),suggestions.appendChild(e);return}for(const[r,a]of t){const n=document.createElement("div");suggestions.appendChild(n);const e=document.createElement("a");e.href=r,n.appendChild(e);const o=document.createElement("span");o.textContent=a.title,o.classList.add("suggestion__title"),e.appendChild(o);const i=document.createElement("span");if(i.textContent=a.description,i.classList.add("suggestion__description"),e.appendChild(i),suggestions.appendChild(n),suggestions.childElementCount==s)break}}})()